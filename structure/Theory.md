# Структуры данных в Python

В Python существует несколько встроенных структур данных, каждая из которых имеет свои особенности и используется для различных задач. Рассмотрим основные из них: список, словарь, множество и кортеж. Также рассмотрим основные операции, которые можно выполнять с этими структурами.

## Список (List)

### Описание
- **Упорядоченный**: Элементы в списке имеют определённый порядок.
- **Изменяемый**: Можно изменять содержимое списка после его создания.
- **Допускает дубликаты**: В списке могут присутствовать одинаковые элементы.
- **Индексируемый**: Доступ к элементам осуществляется по индексам.

### Основные операции

```python
# Создание списка
fruits = ["яблоко", "банан", "вишня"]

# Доступ к элементам по индексу
print(fruits[0])  # Вывод: яблоко

# Добавление элемента в конец списка
fruits.append("финик")

# Вставка элемента по индексу
fruits.insert(1, "апельсин")

# Удаление элемента по значению
fruits.remove("банан")

# Удаление элемента по индексу
del fruits[2]

# Получение длины списка
print(len(fruits))  # Вывод: 3

# Срезы списка
print(fruits[1:3])  # Вывод: ['апельсин', 'финик']

# Итерация по списку
for fruit in fruits:
    print(fruit)
#  extend - Добавляет все элементы из переданного итерируемого объекта в конец спис
fruits = ["яблоко", "банан"]
more_fruits = ["вишня", "апельсин"]
fruits.extend(more_fruits)
print(fruits)  # Вывод: ['яблоко', 'банан', 'вишня', 'апельсин']

# pop - Удаляет элемент по индексу и возвращает его. Если индекс не указан, удаляет и возвращает последний элемент списка.
fruits = ["яблоко", "банан", "вишня"]
removed_fruit = fruits.pop(1)
print(removed_fruit)  # Вывод: банан
print(fruits)         # Вывод: ['яблоко', 'вишня']

 ```
### Основные моменты
- Упорядоченность позволяет обращаться к элементам по их позициям.
- Изменяемость делает списки гибкими для различных операций.
- Дубликаты могут быть полезны, когда необходимо хранить одинаковые элементы.
## Словарь (Dictionary)
### Описание
- Неупорядоченный (до Python 3.7; начиная с Python 3.7 порядок сохранён).
- Изменяемый: Можно добавлять, изменять и удалять пары ключ-значение.
- Уникальные ключи: Каждый ключ должен быть уникальным и неизменяемым (например, строки, числа, кортежи).
- Доступ по ключу: Элементы доступны по ключам, а не по индексам.
### Основные операции
```python
# Создание словаря
person = {"имя": "Алиса", "возраст": 25}

# Доступ к значению по ключу
print(person["имя"])  # Вывод: Алиса

# Добавление новой пары ключ-значение
person["город"] = "Москва"

# Обновление значения по ключу
person["возраст"] = 26

# Удаление пары ключ-значение
del person["город"]

# Получение всех ключей
print(person.keys())  # Вывод: dict_keys(['имя', 'возраст'])

# Получение всех значений
print(person.values())  # Вывод: dict_values(['Алиса', 26])

# Итерация по ключам и значениям
for key, value in person.items():
    print(f"{key}: {value}")

#  popitem - Удаляет и возвращает последнюю добавленную пару ключ-значение из словаря.
person = {"имя": "Алиса", "возраст": 26, "город": "Москва"}
item = person.popitem()
print(item)    # Вывод: ('город', 'Москва')
print(person)  # Вывод: {'имя': 'Алиса', 'возраст': 26}
# Пример использования update
person = {"имя": "Алиса", "возраст": 26}
additional_info = {"город": "Москва", "профессия": "Инженер"}
person.update(additional_info)
print(person)  # Вывод: {'имя': 'Алиса', 'возраст': 26, 'город': 'Москва', 'профессия': 'Инженер'}

```
### Основные моменты
- Пары ключ-значение позволяют эффективно хранить и получать данные.
- Уникальные ключи обеспечивают быстрый доступ к данным.
- Изменяемость позволяет динамически обновлять содержимое словаря. 
## Множество (Set)
### Описание
- Неупорядоченное: Элементы не имеют определённого порядка.
- Изменяемое: Можно добавлять и удалять элементы.
- Нет дубликатов: Множество автоматически удаляет повторяющиеся элементы.
- Неиндексируемое: Доступ к элементам осуществляется без использования индексов.
### Основные операции
```python
# Создание множества
fruits = {"яблоко", "банан", "вишня"}

# Добавление элемента
fruits.add("финик")

# Удаление элемента
fruits.remove("банан")

# Проверка наличия элемента
print("яблоко" in fruits)  # Вывод: True

# Объединение множеств
set1 = {1, 2, 3}
set2 = {3, 4, 5}
print(set1 | set2)  # Вывод: {1, 2, 3, 4, 5}

# Пересечение множеств
print(set1 & set2)  # Вывод: {3}

# Разность множеств
print(set1 - set2)  # Вывод: {1, 2}

# Итерация по множеству
for fruit in fruits:
    print(fruit)
# Пример использования intersection
set1 = {1, 2, 3, 4}
set2 = {3, 4, 5, 6}
common = set1.intersection(set2)
print(common)  # Вывод: {3, 4}

# пример использование difference
set1 = {1, 2, 3, 4}
set2 = {3, 4, 5, 6}

# Разность set1 и set2 (элементы, которые есть в set1, но отсутствуют в set2)
difference_result = set1.difference(set2)
print(difference_result)  # Вывод: {1, 2}

# Разность set2 и set1 (элементы, которые есть в set2, но отсутствуют в set1)
difference_result_reverse = set2.difference(set1)
print(difference_result_reverse)  # Вывод: {5, 6}


```
### Основные моменты
- Отсутствие дубликатов делает множества полезными для хранения уникальных элементов.
- Неупорядоченность может быть преимуществом для некоторых задач, где порядок не важен.
- Быстрая проверка наличия элемента благодаря хешированию.
## Кортеж (Tuple)
### Описание
- Упорядоченный: Элементы имеют определённый порядок.
- Неизменяемый: После создания кортежа его содержимое нельзя изменить.
- Допускает дубликаты: В кортеже могут присутствовать одинаковые элементы.
- Индексируемый: Доступ к элементам осуществляется по индексам.
### Основные операции
```python
Копировать код
# Создание кортежа
fruits = ("яблоко", "банан", "вишня")

# Доступ к элементам по индексу
print(fruits[0])  # Вывод: яблоко

# Срезы кортежа
print(fruits[1:3])  # Вывод: ('банан', 'вишня')

# Конкатенация кортежей
fruits += ("финик",)

# Итерация по кортежу
for fruit in fruits:
    print(fruit)
 ```
### Основные моменты
- Неизменяемость делает кортежи безопасными для хранения данных, которые не должны изменяться.
- Упорядоченность позволяет обращаться к элементам по их позициям.
- Допускает дубликаты аналогично спискам.
## Основные моменты по структурам данных
## Список (List)
- Использовать, когда требуется упорядоченная коллекция изменяемых элементов с возможностью дублирования.
- Примеры применения: хранение последовательности данных, динамическое добавление и удаление элементов.
## Словарь (Dictionary)
- Использовать, когда необходим быстрый доступ к данным по уникальным ключам.
- Примеры применения: хранение связей "ключ-значение", конфигурационные параметры, базы данных в памяти.
## Множество (Set)
- Использовать, когда необходимо хранить уникальные элементы без определённого порядка.
- Примеры применения: удаление дубликатов, проверка наличия элемента, математические операции с множествами.
## Кортеж (Tuple)
- Использовать, когда требуется упорядоченная коллекция неизменяемых элементов.
- Примеры применения: хранение фиксированных наборов данных, возвращение нескольких значений из функции.
