# Техника "Скользящее окно" (Sliding Window)
# Описание:
# Техника "скользящего окна" используется для обработки подмассивов или подстрок
# фиксированного или переменного размера внутри основной структуры данных.
# Это эффективно для задач, связанных с поиском подстрок, сумм или других агрегатов.

# Пример задачи: Найти длину самой длинной подстроки без повторяющихся символов.

def length_of_longest_substring(s):
    """
    Находит длину самой длинной подстроки без повторяющихся символов.

    Аргументы:
    s -- строка, в которой ищется подстрока.

    Возвращает:
    int -- длина самой длинной подстроки без повторяющихся символов.
    """
    char_index = {}  # Словарь для хранения последних позиций символов
    left = 0  # Левый указатель, начало окна
    max_length = 0  # Максимальная длина подстроки без повторяющихся символов

    for right, char in enumerate(s):
        # Если символ уже был в текущем окне, сдвигаем левый указатель вправо
        if char in char_index and char_index[char] >= left:
            left = char_index[char] + 1
        # Обновляем позицию текущего символа
        char_index[char] = right
        # Обновляем максимальную длину подстроки
        max_length = max(max_length, right - left + 1)

    return max_length

# Примеры использования
print(length_of_longest_substring("abcabcbb"))  # Ожидаемый результат: 3 ("abc")
print(length_of_longest_substring("bbbbb"))     # Ожидаемый результат: 1 ("b")
print(length_of_longest_substring("pwwkew"))    # Ожидаемый результат: 3 ("wke")

# Алгоритм решения:
# 1. Инициализировать два указателя `left` и `right`, оба начинаются с начала строки.
# 2. Использовать структуру данных (например, словарь) для хранения последних позиций символов.
# 3. Перемещать указатель `right` вправо, проверяя наличие повторяющихся символов:
#    - Если символ уже встречался внутри текущего окна, сдвинуть `left` вправо до позиции после
#      предыдущего появления этого символа.
#    - Обновлять максимальную длину окна при каждом шаге.

# Когда использовать технику "Скользящее окно":
# 1. При поиске подмассивов или подстрок, удовлетворяющих определённым условиям
#    (например, максимальная сумма, наименьшая длина и т.д.).
# 2. Когда необходимо обработать последовательные элементы, сохраняя некоторую информацию о текущем окне.


# 6
# (поиск максимальной суммы подстроки фиксированной длины):
nums = [1, 2, 3, 4, 5, 6]
k = 3


window_sum = sum(nums[:k]) # начальная сумма - 6
max_sum = window_sum # пока это макс
for i in range(k, len(nums)): # от к двигаемся чтобы другие не смотреть
  window_sum = window_sum +nums[i] - nums[i-k]  #новая_сумма_окна = текущая_сумма_окна + новый_элемент - старый_элемент (6+4-1=9 то есть 2+3+4)
  max_sum = max(max_sum, window_sum) # смотрим где максимум

  # сложность О(н)
max_sum
