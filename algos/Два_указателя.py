# Алгоритм с двумя указателями используется для решения задач, связанных с массивами или строками,
# где требуется найти пары или подмассивы, удовлетворяющие определённым условиям.

# Пример задачи 1: Проверить, содержится ли в строке палиндром (может ли перестановка символов образовать палиндром).

def is_palindrome_permutation(s):
    """
    Проверяет, можно ли перестановкой символов в строке получить палиндром.
    Игнорирует пробелы и регистр символов.
    """
    left, right = 0, len(s) - 1
    s = s.replace(" ", "").lower()
    while left < right:
        if s[left] != s[right]:
            return False
        left += 1
        right -= 1
    return True

# Пример использования
print(is_palindrome_permutation("A man a plan a canal Panama"))  # Ожидаемый результат: True

или
s = "amanaplanacanalpanama"
is_pol = True  # Изначально предполагаем, что строка палиндром
left, right = 0, len(s) - 1

while left < right:
    if s[left] == s[right]:  # Если символы равны, двигаем указатели дальше
        left += 1
        right -= 1
    else:
        is_pol = False  # Если символы не равны, это не палиндром
        break  # Прерываем цикл, так как строка не палиндром

А ЕСЛИ ТАКОЕ ПРИМЕР "A man, a plan, a canal: Panama" ТО НАДО ВЗЯТ ТОКА БУКВЫ
s = "A man, a plan, a canal: Panama".lower()
only_chars = ''.join([char for char in s if char.isalpha()])
reverse_s = only_chars[::-1]

reverse_s ==  only_chars   


# Задача:
# Проверить, является ли данная строка палиндромом (читается одинаково с обеих сторон),
# игнорируя пробелы и регистр символов.

# Алгоритм решения:
# 1. Инициализировать два указателя: left на начало строки и right на конец строки.
# 2. Пока left < right:
#    - Если символы на позициях left и right не равны, вернуть False.
#    - Иначе, сдвинуть left вправо и right влево.
# 3. Если все соответствующие символы совпадают, вернуть True.


# Пример задачи 2: Найти пары элементов в отсортированном массиве, сумма которых равна заданному числу k.

def find_pairs_with_sum(nums, k):
    """
    Находит все уникальные пары элементов в отсортированном массиве,
    сумма которых равна заданному числу k.
    """
    pairs = []
    left, right = 0, len(nums) - 1

    while left < right:
        current_sum = nums[left] + nums[right]
        if current_sum == k:
            pairs.append((nums[left], nums[right]))
            left += 1
            right -= 1
        elif current_sum < k:
            left += 1
        else:
            right -= 1

    return pairs

# Пример использования
print(find_pairs_with_sum([1, 2, 3, 4, 5, 6], 7))  # Ожидаемый результат: [(1, 6), (2, 5), (3, 4)]

# Алгоритм решения:
# 1. Инициализировать два указателя: left на начало массива и right на конец массива.
# 2. Пока left < right:
#    - Вычислить сумму элементов nums[left] + nums[right].
#    - Если сумма равна k, добавить пару в результат и сдвинуть оба указателя.
#    - Если сумма меньше k, сдвинуть указатель left вправо.
#    - Если сумма больше k, сдвинуть указатель right влево.


# Когда использовать алгоритм с двумя указателями:
# 1. Для поиска пар или подмассивов, удовлетворяющих определённым условиям.
# 2. Когда необходимо оптимизировать алгоритмы с временной сложностью ниже O(n²).
# 3. Чаще всего используется с отсортированными массивами или строками.
